{
	"caption": "Popush技术方面学习分析报告",
	"date": "2014-10-26",
	"content": "<p>由于我们组的分工方式并不是每个人负责一个方面，而是每个方面大家都会参与，因此在技术方面也是大家在之前就已经分别自学了很多内容。所以本次作业要求的技术学习报告也是组里的每个人都写了。</p><p>Popush所涉及的开发框架主要包括node.js、socket.IO和Backbone.js，数据库采用的是MongoDB。我们基本确定在现有的平台基础上开发，因此我们的项目所采用的框架也基本上包括这些内容。下面对我所学习的node.js、socket.IO和Backbone.js的相关内容进行总结。</p><h2>1. node.js</h2><p>node.js是一个基于Chrome JavaScript运行时建立的一个平台，用来方便地搭建快速的易于扩展的网络应用。Node.js 借助事件驱动，非阻塞I/O 模型变得轻量和高效，非常适合运行在分布式设备的数据密集型的实时应用。node.js的http模块可以用于快速搭建一个Web服务器并处理HTTP请求。如下的代码就是官方提供的一个最简单的WebServer的例子：</p><pre class=\"brush: js;\">var http = require('http');\nhttp.createServer(function (req, res) {\n  res.writeHead(200, {'Content-Type': 'text/plain'});\n  res.end('Hello World\n');\n}).listen(1337, '127.0.0.1');\nconsole.log('Server running at http://127.0.0.1:1337/');\n</pre><p>通过引用http模块封装的功能可以直接创建Web服务器，监听端口并处理HTTP请求。不过在Popush中并没有使用node.js的这一特性。在Popush中node.js的主要功能是为socket.IO提供一个js运行环境，对应的处理HTTP请求、事件监听机制以及WebSocket双工通信等功能是通过node.js和socket.IO配合完成的。</p><h2>2. socket.IO</h2><p>Socket.IO是一个面向实时web应用的JavaScript库。它使得服务器和客户端之间实时双向的通信成为可能。它有两个部分：在浏览器中运行的客户端库，和一个面向Node.js的服务端库。两者有着几乎一样的API。像node.js一样，它也是事件驱动的。下面是一个使用Socket.IO实现的一个Web多人实时聊天应用。</p><p>首先是服务器端在node.js环境下运行的app.js程序如下：</p><pre class=\"brush: js;\">\nvar fs = require('fs')\n    , http = require('http')\n    , socketio = require('socket.io');\n  var server = http.createServer(function(req, res) {\n    res.writeHead(200, { 'Content-type': 'text/html'});\n    res.end(fs.readFileSync(__dirname + '/index.html'));\n}).listen(8080, function() {\n    console.log('Listening at: http://localhost:8080');\n});\n  socketio.listen(server).on('connection', function (socket) {\n    socket.on('message', function (msg) {\n        console.log('Message Received: ', msg);\n        socket.broadcast.emit('message', msg);\n    });\n});</pre><p>用于传输给客户端的index.html文件内容如下：</p><pre class=\"brush: xml;\">\n&lt;html&gt;\n&lt;head&gt;\n    &lt;script src=\"http://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js\"&gt;&lt;/script&gt;\n    &lt;script src=\"/socket.io/socket.io.js\"&gt;&lt;/script&gt;\n    &lt;script&gt;\n        $(function(){\n            var iosocket = io.connect();\n\n              iosocket.on('connect', function () {\n                $('#incomingChatMessages').append($('&lt;li&gt;Connected&lt;/li&gt;'));\n\n                  iosocket.on('message', function(message) {\n                    $('#incomingChatMessages').append($('&lt;li&gt;&lt;/li&gt;').text(message));\n                });\n                iosocket.on('disconnect', function() {\n                    $('#incomingChatMessages').append('&lt;li&gt;Disconnected&lt;/li&gt;');\n                });\n            });  \n            $('#outgoingChatMessage').keypress(function(event) {\n                if(event.which == 13) {\n                    event.preventDefault();\n                    iosocket.send($('#outgoingChatMessage').val());\n                    $('#incomingChatMessages').append($('&lt;li&gt;&lt;/li&gt;').text($('#outgoingChatMessage').val()));\n                    $('#outgoingChatMessage').val('');                }\n            });\n        });\n    &lt;/script&gt;\n&lt;/head&gt;\n&lt;body&gt;\nIncoming Chat:&nbsp;&lt;ul\nid=\"incomingChatMessages\"&gt;&lt;/ul&gt;\n&lt;br /&gt;\n&lt;input type=\"text\"\nid=\"outgoingChatMessage\"&gt;\n&lt;/body&gt;\n&lt;/html&gt;</pre><p>socket.IO是事件驱动的，或者说是信号驱动的。服务器可以通过socket.emit('message', msg)语句向客户端发送一个message信号，并将传送的数据保存在msg里，客户端可以通过socket.on('message', callback)语句监听到这一message信号，并执行callback函数处理这一信号；反之亦然，客户端可以emit一个信号给服务器，而服务器通过on语句接收信号并处理。</p><p>socket.IO的优势在于它不同于传统的客户端发送request、服务器返回response的模式，而是基于WebSocket，在服务器和每一个客户端都建立起持久的实时双向连接，更像是基于socket的网络编程。服务器甚至还可以通过broadcast向所有客户端发送广播消息，从而实现了在多个客户端中实时显示一个页面的改动。Popush的多人在线代码编辑功能便依赖于此特性。</p><p>（本部分参考自<a href=\"http://www.oschina.net/question/12_54009/\" target=\"_blank\">http://www.oschina.net/question/12_54009/</a>）</p><h2>3. Backbone.js</h2><p>Backbone（也称为 Backbone.js）是由Jeremy Ashkenas创建的一个轻量级库，可用于创建MVC类应用程序。模型、视图、集合和路由器是Backbone框架中的主要组件。在Backbone中，模型会存储通过RESTful JSON接口从服务器检索到的数据。模型与视图密切关联，负责为特定UI组件渲染HTML并处理元素上触发的事件，这也是视图本身的一部分。</p><h3>(1) Backbone.Router和Backbone.History</h3><p>Backbone提供一个称为路由器（版本 0.5 前称之为控制器）的组件来路由客户端状态。路由器可以扩展Backbone.Router函数，且包含一个散列映射（routes 属性）将状态与活动关联起来。当应用程序达到相关状态时，会触发一个特定活动。以下展示了一个Backbone路由器示例：</p><pre class=\"brush: js;\">\nApp.Routers.Main = Backbone.Router.extend({\n\n       // Hash maps for routes\n   routes : {\n      \"\" : \"index\",\n      \"/teams\" : \"getTeams\",\n      \"/teams/:country\" :\n\"getTeamsCountry\",\n      \"/teams/:country/:name : \"getTeam\"\n      \"*error\" : \"fourOfour\"\n   },\n\n      index: function(){\n       // Homepage \n   },\n\n      getTeams: function() {\n       // List all teams \n   },\n   getTeamsCountry: function(country) {\n       // Get list of teams for specific country\n   },\n   getTeam: function(country, name) {\n       // Get the teams for a specific country and with a specific name\n  },\n   fourOfour: function(error) {\n       // 404 page\n   }\n});\n</pre><p>要启动Backbone，先实例化页面加载的路由器，并通过指令Backbone.history.start()方法监视散列片段中的任何变更，如以下所示：</p><pre class=\"brush: js;\">\n$(function(){\n    var router = new App.Routers.Main();\n    Backbone.history.start({pushState : true});\n})\n</pre><h3>(2) Backbone.Model和Backbone.Collection</h3><p>模型和集合是Backbone.js的重要组件，模型将数据（通常是来自服务器的数据）存储在键值对中。要创建一个模型，需要扩展Backbone.Model，如下所示：</p><pre class=\"brush: js;\">\nApp.Models.Team = Backbone.Model.extend({\n    defaults : {\n       // default attributes\n    }\n    // Domain-specific methods go here\n});\nvar team1 = new\nApp.Models.Team();\n</pre><p>现在，变量team1有一个名为cid的字段名，这是一个客户端标识符，形式为\"c\"再加上一个数字（例如，c0、c1、c2）。模型是通过存储在散列映射中的属性来定义的。属性可以在实例化时进行设置，或者使用 set() 方法设置。属性值可通过 get() 方法检索。</p><p>一组模型被分组到到集合中，这个集合是Backbone.Collection的扩展函数。集合具有一个模型属性的特性，定义了组成该集合的模型类型。使用add()/remove()方法可以将一个模型添加和移动到集合中。以下显示了如何创建和填充一个集合：</p><pre class=\"brush: js;\">\nApp.Collections.Teams = Backbone.Collection.extend({\n    model : App.Models.Team\n});\nvar teams = new App.Collections.Teams();\n\n// Add e model to the collection object \"teams\"\nteams.add(team1);\nteams.add(new App.Models.Team({\n    name : \"Team B\"\n}));\nteams.add(new App.Models.Team());\nteams.remove(team1);\n\nconsole.log(teams.length) // prints 2\n</pre><h3>(3) Backbone.View</h3><p>Backbone中的视图与典型MVC方法的视图不一样。Backbone视图可以扩展Backbone.View函数并显示模型中存储的数据。一个视图提供一个由el属性定义的HTML元素。该属性可以是由tagName、className和id属性相组合而构成的，或者是通过其本身的el值形成的。一个视图还必须与一个模型通过相关联。要渲染数据（这是视图的主要目的），重写 render() 方法和逻辑来显示 DOM 元素（由 el 属性引用的）中的模型属性。以下是一个Backbone视图的示例：</p><pre class=\"brush: js;\">\nApp.Views.Team = Backbone.View.extend({\n    className : '.team-element',\n    tagName : 'div',\n    model : new App.Models.Team\n    render : function() {\n        // Render the 'name' attribute of the model associated\n        // inside the DOM element referred by 'el'\n        $(this.el).html(\"<span>\" + this.model.get(\"name\") + \"</span>\");\n    }\n});</pre><p>MVC模式可以为大型JavaScript应用程序提供所需的组织化代码。Backbone是一个JavaScript MVC框架，它属于轻量级框架，且易于学习掌握。模型、视图、集合和路由器从不同的层面划分了应用程序，并负责处理几种特定事件。处理Ajax应用程序或者SPI应用程序时，Backbone可能是最好的解决方案。</p><p>（本部分参考自<a href=\"http://www.ibm.com/developerworks/cn/web/wa-backbonejs/\" target=\"_blank\">http://www.ibm.com/developerworks/cn/web/wa-backbonejs/</a>）</p>"
}

